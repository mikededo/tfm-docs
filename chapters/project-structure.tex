\documentclass[../memory.tex]{subfiles}

\begin{document}
\chapter{Project structure}
\section{Team}
Esto no sé como preferís explicarlo. A tener en cuenta:
\begin{enumerate}[label = -]
	\item Sprints cada dos semanas.
	\item Proyecto en GitHub con las tareas.
	\item Anything else?
\end{enumerate}
\section{Backend}
\section{Frontend}
Regarding the frontend, the application will be stored in a monorepository. The
idea of keeping the code in a single repository is to simplify the workflow of
the developer or developers. By having a single repository, changes in the
domain layer can be made at the same time that the presentation layer is
updated. Nonetheless, this small architecture decisions will be explained more
in depth in further sections.
\subsection{Planning}
When planning the work for the frontend project, our main goal was to avoid
being blocked by backend progress. It is common for frontend and native
developers to fall behind schedule because they are unable to progress until the
backend is complete. One solution to reduce this lag between frontends and
backends is to use GraphQL. However, in our case, we opted to apply GraphQL
ideas in a RESTful API, resulting in the following steps:
\begin{enumerate}[label = -]
	\item Defining the expected request body of a specific endpoint, in order to
	      let the frontend know \emph{what the service expects to receive}.
	\item Defining the response, if any, that an endpoint would return for a given call.
\end{enumerate}
This approach established a clear contract between the backend and the frontend,
with separated implementations that both parties agreed to respect.
\\
To facilitate development, we used a service worker to mock every API call made
in the local environment of a frontend developer. The service worker respected
the specified contract, allowing us to develop the frontend without being
blocked by the backend. Once the app was deployed, the service worker was
disabled, and the API calls were made to the \emph{actual} RESTful API. This
approach allowed for fast and non-blocking development for both frontend and
backend.
\\[8pt]
The second thing to take into account before starting to structure and develop
the frontend are the designs. Since there was not enough time to create a system
design and then enough designs that would cover all use cases of our app, we
opted for simple designs, which are shown in later sections. As a first sprint,
or sprint zero, I was in charge of prototyping the frontend application, which
would simplify the process of developing the frontend app.
\\[8pt]
Next steps are more involved in the development and architecture of the
application. As explained in previous sections, we got together every two weeks,
as well as keeping an asynchronous communication. We considered each meeting to
be a deadline, and in the meeting we would discuss the next steps to take or
changes if any. However, since there are always unexpected tasks, it has not
been easy to strictly follow the devised roadmap. The following diagram
illustrates an aproximate planning of the sprints.
\\
\textbf{TODO: Roadmap picture}
\subsubsection{Sprint 0 and 1}
As explained previously, the goal of the sprint 0 was to start prototyping the
application. Since there was no system design defined, it took a bit more than
two weeks to finish the prototypes, even though the were some part that would
change in a future.
\\
The design not only helped us visualise the entities and important parts of our
application, but also helped me architecture the monorepository. Once tool used
to simplify the developer experience is Nx. Using such build system, tasks as
having internal libraries and separated applications are easily handled.
Therefore, the goal of the sprint 1 was to set up the repository and have it
ready to roll. As I was defining the architecture of it, I was able to test
possible use cases that I could come across while developing the frontend. This
helped me prevent possible time-consuming issues, by handling them in an early
stage.
\\
One of the requirements for developing the application was to follow hexagonal
architecture patterns and domain-driven design. However, frontend frameworks and
technologies often deviate from traditional structures. For example, the React
framework primarily uses composition over inheritance and follows a reactive
paradigm. As a result, applying these concepts to the frontend posed a
significant challenge. More details about the final design will be provided in
subsequent chapters.
\subsubsection{Sprint 2}
Once the architecture was defined, the first goal of the sprint was to develop
the frontend domain logic for user sign up and sign in. As the first code
written for the core frontend, it was important to establish a solid structure
that could easily accommodate changes. The initial architecture planning proved
successful, with the following benefits:
\begin{enumerate}[label = -]
	\item The hexagonal architecture layers (domain, application, and
	      infrastructure) could be easily decoupled.
	\item The structure could be easily refactored and scaled as needed.
	\item The domain logic was separated from the frontend implementation, making
	      it reusable.
\end{enumerate}
Once the domain was defined and ready to be connected to a frontend application,
the next step was to implement the authentication pages. This process was
divided into two steps:
\begin{enumerate}[label = \arabic{*}.]
	\item Since most components had yet to be created, an initial implementation
	      was created in the respective package. This implementation was open to
	      modifications and designed to be reusable within different applications,
	      although it was already attached to the React framework.
	\item With the components created and the business logic defined, the last
	      step was to connect both through the view layer.
\end{enumerate}
Once the architecture had been defined, the goal of the sprint was to start
developing the domain of the frontend that will contain the logic to sign up and
sign in a user. Being the first code written in the core of the frontend, it was
very sensitive to change in terms of structure. However, the initial
architecture planning turned out to work seamlessly well, this being:
\begin{enumerate}[label = -]
	\item Easily decoupling the diferent layers from the hexagonal architecture
	      (domain, application and infrastructure).
	\item Simplicity to escalate the context as well as to refactor it.
	\item Containing only business logic code, being completely unaware of any
	      frontend implementation, which allows such logic to be reused.
\end{enumerate}
Once the domain have been defined and was ready to be connected to a fronent
application, the next step was to start implementing the authentication pages of
the design. This process was divided in two steps:
\begin{enumerate}[label = \arabic{*}.]
	\item Most of the components had yet to be created, therefore an initial
	      implementation, open to modifications, was created in the respective
	      package. Note that, even though it is only used in one application, another
	      idea of the components internal library is that it can be reused within
	      different applications. However, it is already attached to a framework,
	      which, in this case, is React.
	\item Having the components created and the business logic defined, the last
	      step was a simple as connecting both through the view layer.
\end{enumerate}
\subsubsection{Sprint 3 and further}
The past few sprints have been somewhat relaxed due to some meetings coinciding
with local bank holidays and being postponed. Nevertheless, the focus was on
ensuring that the product meets its minimum requirements, which include listing
travels created by the user, enabling the creation, update, and deletion of
travels, and ensuring proper authentication protection for the application.
\\[8pt]
The initial implementation of the travel listing followed the agreements made
during Sprint 0, but little thought had been given to its design, resulting in a
rather poor implementation. However, after one of the meetings, we agreed on a
more complex concept of travel, which required updating the initial core
implementation of the frontend. Fortunately, the initial design was open to
extension, making the required changes easy to implement. This was also a way of
testing whether the structure of the context library was well-designed or not.
\\[8pt]
\textbf{TODO: Explain deployment process}
\end{document}
